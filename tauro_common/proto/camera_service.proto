syntax = "proto3";

package tauro.common.proto;

import "google/protobuf/timestamp.proto";
import "google/protobuf/empty.proto";

// Camera service for image capture and streaming
service CameraService {
  // Start streaming images from specified cameras
  rpc StreamImages(StreamRequest) returns (stream ImageFrame);
  
  // Capture a single frame from specified cameras
  rpc CaptureFrame(CaptureRequest) returns (ImageFrame);
  
  // Update stream parameters without restarting
  rpc UpdateStreamParameters(UpdateStreamRequest) returns (UpdateStreamResponse);
  
  // Get available cameras and their status
  rpc GetCameraInfo(google.protobuf.Empty) returns (CameraInfoResponse);
  
  // Stop all active streams
  rpc StopAllStreams(google.protobuf.Empty) returns (StopStreamResponse);
}

// Request to start streaming
message StreamRequest {
  repeated string camera_ids = 1;  // e.g., ["left", "right", "depth"]
  CameraConfig config = 2;
}

// Request to capture a single frame
message CaptureRequest {
  repeated string camera_ids = 1;
  CameraConfig config = 2;
}

// Camera configuration
message CameraConfig {
  uint32 width = 1;
  uint32 height = 2;
  uint32 fps = 3;  // For streaming only
  uint32 jpeg_quality = 4;  // 0-100, default 85
  bool skip_frames_on_lag = 5;  // Drop frames if network is slow
}

// Image frame containing one or more camera images
message ImageFrame {
  google.protobuf.Timestamp timestamp = 1;  // For synchronization with robot state
  repeated CameraImage images = 2;
  uint64 frame_id = 3;  // Sequential frame counter
}

// Single camera image
message CameraImage {
  string camera_id = 1;  // e.g., "left", "right"
  oneof image_data {
    CompressedJPGData jpg_data = 2;  // JPEG compressed RGB image
    CompressedRGBDData rgbd_data = 3;  // Compressed RGB-D raw data
  }
  uint32 width = 4;
  uint32 height = 5;
  FrameMetadata metadata = 6;
  CameraIntrinsics intrinsics = 7;  // Optional, if available
  CameraStatus status = 8;
}

// Compressed JPEG data
message CompressedJPGData {
  bytes jpeg_data = 1;  // JPEG compressed image
}

// Compressed RGB-D raw data
message CompressedRGBDData {
  bytes color_compressed = 1;  // Compressed color data
  bytes depth_compressed = 2;  // Compressed depth data
  float depth_scale = 3;  // Depth unit in meters (e.g., 0.001 for mm)
  float min_depth = 4;  // Minimum valid depth in meters
  float max_depth = 5;  // Maximum valid depth in meters
}

// Frame metadata
message FrameMetadata {
  uint32 exposure_us = 1;  // Exposure time in microseconds
  float gain_db = 2;  // Gain in decibels
  uint64 hardware_timestamp_ns = 3;  // Hardware timestamp if available
  float brightness = 4;  // Average brightness 0-1
}

// Camera intrinsics for computer vision
message CameraIntrinsics {
  float fx = 1;  // Focal length x
  float fy = 2;  // Focal length y
  float cx = 3;  // Principal point x
  float cy = 4;  // Principal point y
  repeated float distortion_coeffs = 5;  // k1, k2, p1, p2, k3
  uint32 width = 6;  // Image width these intrinsics apply to
  uint32 height = 7;  // Image height these intrinsics apply to
}

// Update stream parameters request
message UpdateStreamRequest {
  repeated string camera_ids = 1;  // Which cameras to update
  CameraConfig config = 2;  // New configuration
}

// Update stream response
message UpdateStreamResponse {
  bool success = 1;
  string message = 2;
  map<string, bool> camera_results = 3;  // Per-camera success status
}

// Camera information response
message CameraInfoResponse {
  map<string, CameraDetails> cameras = 1;  // camera_id -> details
}

// Camera details
message CameraDetails {
  string device_id = 1;  // e.g., "/dev/video0" or "realsense://0"
  string type = 2;  // e.g., "usb", "realsense", "mipi"
  CameraStatus status = 3;
  repeated Resolution supported_resolutions = 4;
  CameraIntrinsics intrinsics = 5;  // If calibrated
  map<string, string> properties = 6;  // Additional properties
}

// Supported resolution
message Resolution {
  uint32 width = 1;
  uint32 height = 2;
  repeated uint32 fps_options = 3;  // Supported FPS values
}

// Stop stream response
message StopStreamResponse {
  bool success = 1;
  string message = 2;
  uint32 streams_stopped = 3;
}

// Camera status enum
enum CameraStatus {
  CAMERA_STATUS_UNKNOWN = 0;
  CAMERA_STATUS_OK = 1;
  CAMERA_STATUS_DISCONNECTED = 2;
  CAMERA_STATUS_BUSY = 3;
  CAMERA_STATUS_ERROR = 4;
  CAMERA_STATUS_INITIALIZING = 5;
}